---
title: "Coding Exercise Options and Derivatives"
authors: "Stephan Blum 12141035
date: "2024-11-20"
output: pdf_document
editor_options: 
  markdown: 
    wrap: 72
---

# 1. Binomial Option Pricing Model

This report explains the Binomial Option Pricing Model implemented in
R. The model computes the price of a European call option using a
TT-period binomial tree, where the stock price evolves according to
discrete upward or downward movements.

We describe the steps in detail, including the calculations for stock
prices, option payoffs at maturity, and backward induction for option
valuation.

Model Parameters and Formulas:

-   $T$: Number of time steps in the binomial tree.
-   $S$: Initial stock price.
-   $K$: Strike price of the option.
-   $R_u$: Upward movement factor ($R_u > 1$).
-   $R_d$: Downward movement factor ($R_d < 1$).

The R code is as follows:

```{r explicit-binomial, echo=TRUE}
explicit_binomial <- function(T, S, K, Ru, Rd) {
  # Step 1: Initialize a matrix with dimensions (T+1) x (T+1)
  price_matrix <- matrix(0, nrow = T + 1, ncol = T + 1)
  
  # Step 2: Calculate stock prices at maturity (t = T)
  for (i in 0:T) {
    price_matrix[i + 1, T + 1] <- S * Ru^i * Rd^(T - i)
  }
  
  # Step 3: Calculate option payoffs at maturity
  price_matrix[, T + 1] <- pmax(price_matrix[, T + 1] - K, 0)
  
  # Step 4: Perform backward induction
  for (t in (T - 1):0) {
    for (i in 0:t) {
      price_matrix[i + 1, t + 1] <- 0.5 * (price_matrix[i + 1, t + 2] + 
                                             price_matrix[i + 2, t + 2])
    }
  }
  
  return(price_matrix)
}
```

The above described code has the following elements:

1.  We define a $(T+1) \times (T+1)$ sized matrix, where rows
    represent different states and columns represent time steps.

2.  The stock price at time $t$ is calculated using:

$$
S_{t,i} = S \cdot R_u^i \cdot R_d^{t-i}
$$

3.  The payoff of a call option at maturity is given by:

$$
C_T = \max(S_T - K, 0)
$$

4.  The option price at earlier times is calculated recursively:

$$
C_{t,i} = 0.5 \cdot \left( C_{t+1,i} + C_{t+1,i+1} \right)
$$

In the next segment, we plug in the given values for our variables: -
$T = 100$ - $S = 100$ - $K = 100$ - $R_u = 1.02$ - $R_d = 0.99$

We compute the price matrix and extract the call price at $t = 0$.

```{r price_matrix_4, echo=TRUE}
# Parameter from c)
T <- 100
S <- 100
K <- 100
Ru <- 1.02
Rd <- 0.99

price_matrix_4 <- explicit_binomial(T, S, K, Ru, Rd)
explicit_price <- price_matrix_4[1, 1]  # Call price at time 0
cat("Explicit Call Price:", explicit_price, "\n")

```

# 2. Monte Carlo Simulation for Binomial Option Pricing

In this section, we will implement a Monte Carlo simulation to
approximate the option price. The simulation will generate multiple
sample paths of the stock price using the risk-neutral measure. For
each sample path, we calculate the corresponding final value of the
option and compute the running average.

```{r montecarlo-simulation, echo=TRUE, fig.width=10, fig.height=6}
# Monte Carlo Simulation for Binomial Option Pricing
monte_carlo_binomial <- function(T, S, K, Ru, Rd, N) {
  running_avg <- numeric(N)
  
  for (n in 1:N) {
    # Generate a random path
    steps <- sample(c(Ru, Rd), T, replace = TRUE, prob = c(0.5, 0.5))
    path_price <- S * prod(steps)  # Final price of the stock
    
    # Compute the call payoff
    payoff <- max(path_price - K, 0)
    
    # Update running average
    running_avg[n] <- if (n == 1) payoff else 
      (running_avg[n - 1] * (n - 1) + payoff) / n
  }
  
  return(running_avg)
}

# Parameters
N <- 10000  # Number of sample paths


# Run Monte Carlo simulation
running_avg <- monte_carlo_binomial(T, S, K, Ru, Rd, N)

# Check if running_avg has been computed properly
if (length(running_avg) > 0) {
  # Initialize the plot with running average values
  plot(1:N, running_avg, type = "l", col = "black", lwd = 3,
       # Thicker line for better visibility
       xlab = "Number of Simulations", ylab = "Running Average",
       main = "Monte Carlo: Running Average of Call Prices",
       ylim = c(50, max(running_avg) + 10))  #Set y-axis limits starting from 50
  
  # Add explicit price line for comparison
  abline(h = explicit_price, col = "red", lwd = 2, lty = 2)
  
  # Add a legend to the plot
  legend("topright", legend = c("Monte Carlo", "Explicit Price"), 
         col = c("black", "red"),
         lty = c(1, 2), lwd = 2)
  
  # Customize y-axis ticks starting from 50 in steps of 5
  axis(2, at = seq(50, ceiling(max(running_avg) + 10), by = 5))
  
  # Optionally, set x-axis breaks for clearer visualization
  axis(1, at = seq(0, N, by = 1000))  # Adjust based on the number of simulations
  
} else {
  cat("Error: Running average is empty.\n")
}







```

#Exercise 2:Hedging

#a) Explicit Binomial Model with Delta Calculation

The function initializes the price and delta matrices and takes the
following inputs: 
- $T$: Number of time steps. 
- $S$: Initial stock
price. 
- $K$: Strike price. 
- $R_u$ and $R_d$: Upward and downward
factors for stock price changes.

### R Code:

```{r explicit_binomial_with_delta_1, CACHE = TRUE}
#(a): Generate Price Matrix and Delta Matrix
explicit_binomial_with_delta_1 <- function(T, S, K, Ru, Rd) {
  # Initialize price matrix and delta matrix
  price_matrix <- matrix(0, nrow = T + 1, ncol = T + 1)
  delta_matrix <- matrix(0, nrow = T, ncol = T)
  
  # Calculate stock prices and option payoffs at maturity
  for (i in 0:T) {
    price_matrix_a[i + 1, T + 1] <- S * Ru^i * Rd^(T - i)
  }
  
  # Calculate the call option payoff at maturity
  price_matrix_a[, T + 1] <- pmax(price_matrix[, T + 1] - K, 0)
  
  # Backward induction to calculate option prices and delta
  for (t in (T - 1):0) {
    for (i in 0:t) {
  # Option price at current time and state
  price_matrix_a[i + 1, t + 1] <- 0.5 * (price_matrix_a[i + 1, t + 2] + 
                                           price_matrix_a[i + 2, t + 2])
      
  # Calculate delta (the option's sensitivity to the stock price)
  delta_matrix[i + 1, t + 1] <-
    (price_matrix_a[i + 2, t + 2] - price_matrix_a[i + 1, t + 2]) / 
    (S * (Ru - Rd))
    }
  }
  
  return(list(price_matrix = price_matrix_a, delta_matrix = delta_matrix_a))
}
```

Stock prices and payoff at maturity: At maturity (t = T), the stock
price for each state is calculated as:

$$
S_{\text{state}} = S \cdot R_u^i \cdot R_d^{T-i}
$$

The call option payoff at maturity is given by:

$$
\text{Payoff} = \max(S\_{\text{state}} - K, 0)
$$

```{r price_matrix, CACHE = TRUE}

T <- 100
S <- 100
K <- 100
Ru <- 1.02
Rd <- 0.99

# Initialize the price_matrix
price_matrix <- matrix(0, nrow = T + 1, ncol = T + 1)

# Loop to fill the price matrix
for (i in 0:T) {
  price_matrix[i + 1, T + 1] <- S * Ru^i * Rd^(T - i)
}

# Update the last column to reflect option payoff
price_matrix[, T + 1] <- pmax(price_matrix[, T + 1] - K, 0)



for (i in 0:T) {
  price_matrix[i + 1, T + 1] <- S * Ru^i * Rd^(T - i)
}
price_matrix[, T + 1] <- pmax(price_matrix[, T + 1] - K, 0)
```

Backward induction:

Option prices are calculated recursively from maturity to the initial
time (t = 0) using:

$$
\text{Option Price} = 0.5 \cdot (\text{Option Price at Upward State} + \text{Option Price at Downward State})
$$

The Delta is calculated as:

$$
\Delta = \frac{\text{Option Price at Upward State} - \text{Option Price at Downward State}}{S \cdot (R_u - R_d)}
$$

```{r explicit_binomial_with_delta, CACHE = TRUE}
explicit_binomial_with_delta <- function(T, S, K, Ru, Rd) {
  # Initialize price matrix and delta matrix
  price_matrix_a <- matrix(0, nrow = T + 1, ncol = T + 1)
  delta_matrix <- matrix(0, nrow = T, ncol = T)
  
  # Calculate stock prices and option payoffs at maturity
  for (i in 0:T) {
    price_matrix_a[i + 1, T + 1] <- S * Ru^i * Rd^(T - i)
  }
  
  # Calculate the call option payoff at maturity
  price_matrix_a[, T + 1] <- pmax(price_matrix_a[, T + 1] - K, 0)
  
  # Backward induction to calculate option prices and delta
  for (t in (T - 1):0) {
    for (i in 0:t) {
      # Option price at current time and state
      price_matrix_a[i + 1, t + 1] <- 
        0.5 * (price_matrix_a[i + 1, t + 2] + price_matrix_a[i + 2, t + 2])
      
      # Calculate delta (the option's sensitivity to the stock price)
      delta_matrix[i + 1, t + 1] <- 
        (price_matrix_a[i + 2, t + 2] - price_matrix_a[i + 1, t + 2]) / 
        (S * (Ru - Rd))
    }
  }
  
  # Return both price matrix and delta matrix
  return(list(price_matrix = price_matrix_a, delta_matrix = delta_matrix))
}

T <- 100
S <- 100
K <- 100
Ru <- 1.02
Rd <- 0.99

# Call the function and store the result
result <- explicit_binomial_with_delta(T, S, K, Ru, Rd)

# Extract price matrix and delta matrix
price_matrix <- result$price_matrix
delta_matrix <- result$delta_matrix

```

#b) Generating sample path of binomial and hedging portfolio

We simulate a sample path for the binomial model and compute the
hedging portfolio at each time step. The portfolio is rebalanced to
match the option's delta at every step.

Logic:

1.  The stock price follows a binomial process with upward $R_u$ and
    downward $R_d$ movements.

2.  The portfolio at time t is: $$
    V_t = \Delta\_t \cdot S_t - (C_t - \Delta\_t \cdot S_t)
    $$

3.  The portfolio is adjusted at each step to match the delta of the
    option

```{r hedging_portfolio, CACHE = TRUE}
hedging_portfolio <- function(T, S, K, Ru, Rd, delta_matrix) {
# Initialize arrays for stock prices, option prices, portfolio values and deltas
  stock_prices <- numeric(T + 1)
  option_prices <- numeric(T + 1)
  portfolio_values <- numeric(T + 1)
  deltas <- numeric(T + 1)
  
# Initial stock price and option price
  stock_prices[1] <- S
  option_prices[1] <- price_matrix[1, 1]  # Price at time 0
  deltas[1] <- delta_matrix[1, 1]  # Delta at time 0
  
# Initialize the portfolio at time 0
  portfolio_values[1] <- deltas[1] * S - (option_prices[1] - deltas[1] * S)
  
# Simulate the binomial path and calculate the hedging portfolio
  for (t in 1:T) {
    # Update stock price based on upward or downward movement
    if (runif(1) < 0.5) {
      stock_prices[t + 1] <- stock_prices[t] * Ru  # Upward movement
    } else {
      stock_prices[t + 1] <- stock_prices[t] * Rd  # Downward movement
    }
    
    # Calculate delta at time t (use correct indexing)
    if (t < T) {
      #Ensure indexing is within bounds
      deltas[t + 1] <- delta_matrix[t + 1, min(t + 1, T)]
    } else {
      deltas[t + 1] <- delta_matrix[t, T]  # At the final step, use last value
    }
    
# Update option price (assuming option price follows backward induction logic)
    option_prices[t + 1] <- 0.5 * (option_prices[t] + option_prices[t + 1])
        
# Update portfolio value at time t+1
    portfolio_values[t + 1] <- 
      deltas[t + 1] * 
      stock_prices[t + 1] - 
      (option_prices[t + 1] - 
         deltas[t + 1] * 
         stock_prices[t + 1])
  }
  
  return(list(stock_prices = stock_prices, option_prices = option_prices, 
              portfolio_values = portfolio_values, deltas = deltas))
}

# Run the simulation for hedging portfolio
hedging_result <- hedging_portfolio(T, S, K, Ru, Rd, delta_matrix)

# Ensure hedging_result has the necessary data
if (exists("hedging_result") && 
    all(c("stock_prices", "deltas", 
          "option_prices", 
          "portfolio_values") %in% names(hedging_result))) {

# Set minimum and maximum values for the plot
  min_value <- 
    min(c(hedging_result$stock_prices, 
          hedging_result$deltas * max(hedging_result$stock_prices), 
          hedging_result$option_prices, 
          hedging_result$portfolio_values), na.rm = TRUE)
  max_value <- 
    max(c(hedging_result$stock_prices, 
          hedging_result$deltas * max(hedging_result$stock_prices), 
          hedging_result$option_prices, hedging_result$portfolio_values), 
        na.rm = TRUE)

# Create the initial plot for stock prices
  plot(1:(T + 1), hedging_result$stock_prices, type = "l", col = "blue", 
       xlab = "Time", ylab = "Value", ylim = c(min_value, max_value), 
       main = "Stock Price, Delta, Option Price, and Portfolio Value")
  
# Add lines for the remaining variables
  #Rescale delta to match range
  lines(1:(T + 1), hedging_result$deltas * max_value, col = "green")
  lines(1:(T + 1), hedging_result$option_prices, col = "red")
  lines(1:(T + 1), hedging_result$portfolio_values, col = "purple")

# Add a legend
legend("topright", legend = c("Stock Price", "Delta", "Option Price", 
                              "Portfolio Value"), 
         col = c("blue", "green", "red", "purple"), lty = 1)
} else {
  cat("Error: 'hedging_result' does not contain the necessary data.\n")
}

```

#c) Adjust Hedging Portfolio Every Other Period

Here, we adjust the hedging portfolio only every other period. The
portfolio value is maintained, but the equity holdings are updated to
match the option delta.

1.  Adjust the hedging portfolio every p, where p = 2.
2.  Portfolio value remains constant between rebalancing.
3.  Stock prices follow the binomial process as before.

```{r stock_prices, CACHE = TRUE}
adjusted_hedging_portfolio <- 
  function(T, S, K, Ru, Rd, delta_matrix, 
           rebalancing_period = 2) {
  stock_prices <- numeric(T + 1)
  option_prices <- numeric(T + 1)
  portfolio_values <- numeric(T + 1)
  deltas <- numeric(T + 1)
  
  stock_prices[1] <- S
  option_prices[1] <- price_matrix[1, 1]
  deltas[1] <- delta_matrix[1, 1]
  portfolio_values[1] <- deltas[1] * S
  
  for (t in 1:T) {
    if (runif(1) < 0.5) {
      stock_prices[t + 1] <- stock_prices[t] * Ru
    } else {
      stock_prices[t + 1] <- stock_prices[t] * Rd
    }
    if (t %% rebalancing_period == 0) {
      deltas[t + 1] <- delta_matrix[t + 1, t + 1]
      portfolio_values[t + 1] <- deltas[t + 1] * stock_prices[t + 1]
    } else {
      portfolio_values[t + 1] <- portfolio_values[t]
    }
  }
  
  return(list(stock_prices = stock_prices, option_prices = option_prices, 
              portfolio_values = portfolio_values, deltas = deltas))
}

# Ensure the delta_matrix is properly initialized with the correct size
delta_matrix <- matrix(0, nrow = T + 1, ncol = T + 1)

# Perform the backward iteration for pricing and delta calculation
for (t in (T - 1):0) {
  for (i in 0:t) {
    # Ensure the indices are within the bounds
    if (t + 1 <= T + 1 && i + 1 <= T + 1) {
      price_matrix[i + 1, t + 1] <- 
        0.5 * (price_matrix[i + 1, t + 2] + price_matrix[i + 2, t + 2])
      
      # Calculate delta safely with proper indexing
      if (i + 2 <= T + 1) {
        delta_matrix[i + 1, t + 1] <- 
          (price_matrix[i + 2, t + 2] - price_matrix[i + 1, t + 2]) / 
          (S * (Ru - Rd))
      }
    }
  }
}

# Now you can call the adjusted_hedging_portfolio function safely
adjusted_result <- adjusted_hedging_portfolio(T, S, K, Ru, Rd, delta_matrix)


# Ensure that adjusted_result has valid data
if (length(adjusted_result$stock_prices) > 
    0 && length(adjusted_result$option_prices) > 
    0 && length(adjusted_result$portfolio_values) > 0) {
  
# Initialize the plot with stock prices
  plot(1:(T + 1), adjusted_result$stock_prices, type = "l", col = "blue", 
       lwd = 2, 
       xlab = "Time", ylab = "Value", ylim = c(min_value, max_value), 
       main = "Adjusted Hedging Portfolio")
  
# Add lines for option prices and portfolio values
  lines(1:(T + 1), adjusted_result$option_prices, col = "red", lwd = 2)
  lines(1:(T + 1), adjusted_result$portfolio_values, col = "green", lwd = 2)

# Add a legend to the top right corner
  legend("topright", legend = c("Stock Price", "Option Price", 
                                "Portfolio Value"), 
         col = c("blue", "red", "green"), lty = 1, lwd = 2)
  
} else {
# Error message if the data is not valid
  print("Error: Invalid or empty data in adjusted_result. 
        Please check the data structure.")
}


```

#d) Monte Carlo Method for Tracking Error

We calculate the tracking error using Monte Carlo simulations. The
tracking error is the standard deviation of the difference between the
portfolio value and the option value at each time.

Logic:

1.Run "N" Monte Carlo simulations.

2.Compute the difference between the portfolio and option values at
each time step.

3.Calculate the standard deviation of these differences as the
tracking error.

```{r tracking_error_montecarlo, CACHE = TRUE}
tracking_error_montecarlo <- function(T, S, K, Ru, Rd, N) {
  tracking_errors <- numeric(T + 1)
  
  for (i in 1:N) {
    portfolio_result <- hedging_portfolio(T, S, K, Ru, Rd, delta_matrix)
    error <- portfolio_result$portfolio_values - portfolio_result$option_prices
    tracking_errors <- tracking_errors + error^2
  }
  
  return(sqrt(tracking_errors / N))
}

N <- 10000
tracking_error_result <- tracking_error_montecarlo(T, S, K, Ru, Rd, N)

plot(1:(T + 1), tracking_error_result, type = "l", col = "purple", 
     xlab = "Time", ylab = "Tracking Error", main = "Tracking Error Over Time")
```

---
title: "Coding Exercise Options and Derivatives"
author: "Stephan Blum 12141035
Paul Moritz Nikolaus DuffhauÃŸ 12405876
Shokhjakhon Normamatov 12310408
Nikolai Zalivatskij"
date: "2024-11-20"
output: "pdf_document"
---

# 1. Binomial Option Pricing Model

This report explains the Binomial Option Pricing Model implemented in
R. The model computes the price of a European call option using a
TT-period binomial tree, where the stock price evolves according to
discrete upward or downward movements.

We describe the steps in detail, including the calculations for stock
prices, option payoffs at maturity, and backward induction for option
valuation.

Model Parameters and Formulas:

- $T$: Number of time steps in the binomial tree.
- $S$: Initial stock price.
- $K$: Strike price of the option.
- $R_u$: Upward movement factor ($R_u > 1$).
- $R_d$: Downward movement factor ($R_d < 1$).

The R code is as follows:

```{r explicit-binomial, echo=TRUE}
explicit_binomial_with_delta_1 <- function(T, S, K, Ru, Rd) {
  # Initialize price matrix and delta matrix
  price_matrix <- matrix(0, nrow = T + 1, ncol = T + 1)
  delta_matrix <- matrix(0, nrow = T, ncol = T)  #Corrected matrix initialization
  
  # Calculate stock prices and option payoffs at maturity
  for (i in 0:T) {
    price_matrix[i + 1, T + 1] <- S * Ru^i * Rd^(T - i)  # Fix matrix reference
  }
  
  # Calculate the call option payoff at maturity
  price_matrix[, T + 1] <- pmax(price_matrix[, T + 1] - K, 0)
  
  # Backward induction to calculate option prices and delta
  for (t in (T - 1):0) {
    for (i in 0:t) {
      # Option price at current time and state
      price_matrix[i + 1, t + 1] <- 0.5 * (price_matrix[i + 1, t + 2] + 
                                           price_matrix[i + 2, t + 2])
      
      # Calculate delta (the option's sensitivity to the stock price)
      delta_matrix[i + 1, t + 1] <- 
        (price_matrix[i + 2, t + 2] - price_matrix[i + 1, t + 2]) / 
        (S * (Ru - Rd))
    }
  }
  
  return(list(price_matrix = price_matrix, delta_matrix = delta_matrix))
}

```

The above described code has the following elements:

1.  We define a $(T+1) \times (T+1)$ sized matrix, where rows
    represent different states and columns represent time steps.

2.  The stock price at time $t$ is calculated using:

$$
S_{t,i} = S \cdot R_u^i \cdot R_d^{t-i}
$$

3.  The payoff of a call option at maturity is given by:

$$
C_T = \max(S_T - K, 0)
$$

4.  The option price at earlier times is calculated recursively:

$$
C_{t,i} = 0.5 \cdot \left( C_{t+1,i} + C_{t+1,i+1} \right)
$$

In the next segment, we plug in the given values for our variables: -
$T = 100$ - $S = 100$ - $K = 100$ - $R_u = 1.02$ - $R_d = 0.99$

We compute the price matrix and extract the call price at $t = 0$.

```{r price_matrix_4, echo=TRUE}
explicit_binomial <- function(T, S, K, Ru, Rd) {
  # Initialize parameters
  dt <- 1 / T  # Time step
  u <- Ru  # Up factor
  d <- Rd  # Down factor
  p <- (1 - d) / (u - d)  # Risk-neutral probability

  # Create the price matrix (T + 1 x T + 1)
  price_matrix <- matrix(0, nrow = T + 1, ncol = T + 1)
  
  # Initialize option prices at maturity (at time T)
  
  for (i in 0:T) {
    #Call option payoff
    price_matrix[T + 1, i + 1] <- max(S * u^i * d^(T - i) - K, 0)
  }
  
  # Compute option prices at each previous time step
  for (t in (T - 1):0) {
    for (i in 0:t) {
      price_matrix[t + 1, i + 1] <- exp(-0.05 * dt) * 
        (p * price_matrix[t + 2, i + 2] + (1 - p) * price_matrix[t + 2, i + 1])
    }
  }
  
  return(price_matrix)
}

# Parameter from c)
T <- 100
S <- 100
K <- 100
Ru <- 1.02
Rd <- 0.99

price_matrix <- explicit_binomial(T, S, K, Ru, Rd)
explicit_price <- price_matrix[1, 1]  # Call price at time 0
cat("Explicit Call Price:", explicit_price, "\n")

```
Explicit Call Price: 64.66873 
# 2. Monte Carlo Simulation for Binomial Option Pricing

In this section, we will implement a Monte Carlo simulation to
approximate the option price. The simulation will generate multiple
sample paths of the stock price using the risk-neutral measure. For
each sample path, we calculate the corresponding final value of the
option and compute the running average.

```{r montecarlo-simulation, echo=TRUE, fig.width=10, fig.height=6}
# Monte Carlo Simulation for Binomial Option Pricing
monte_carlo_binomial <- function(T, S, K, Ru, Rd, N) {
  running_avg <- numeric(N)
  
  for (n in 1:N) {
    # Generate a random path
    steps <- sample(c(Ru, Rd), T, replace = TRUE, prob = c(0.5, 0.5))
    path_price <- S * prod(steps)  # Final price of the stock
    
    # Compute the call payoff
    payoff <- max(path_price - K, 0)
    
    # Update running average
    running_avg[n] <- if (n == 1) payoff else 
      (running_avg[n - 1] * (n - 1) + payoff) / n
  }
  
  return(running_avg)
}

# Parameters
N <- 10000  # Number of sample paths


# Run Monte Carlo simulation
running_avg <- monte_carlo_binomial(T, S, K, Ru, Rd, N)

# Check if running_avg has been computed properly
if (length(running_avg) > 0) {
  # Initialize the plot with running average values
  plot(1:N, running_avg, type = "l", col = "black", lwd = 3,
       # Thicker line for better visibility
       xlab = "Number of Simulations", ylab = "Running Average",
       main = "Monte Carlo: Running Average of Call Prices",
       ylim = c(50, max(running_avg) + 10))  #Set y-axis limits starting from 50
  
  # Add explicit price line for comparison
  abline(h = explicit_price, col = "red", lwd = 2, lty = 2)
  
  # Add a legend to the plot
  legend("topright", legend = c("Monte Carlo", "Explicit Price"), 
         col = c("black", "red"),
         lty = c(1, 2), lwd = 2)
  
  # Customize y-axis ticks starting from 50 in steps of 5
  axis(2, at = seq(50, ceiling(max(running_avg) + 10), by = 5))
  
  # Optionally, set x-axis breaks for clearer visualization
  axis(1, at = seq(0, N, by = 1000))  #Adjust based on the number of simulations
  
} else {
  cat("Error: Running average is empty.\n")
}
```

#Exercise 2:Hedging

#a) Explicit Binomial Model with Delta Calculation

The function initializes the price and delta matrices and takes the
following inputs: 
- $T$: Number of time steps. 
- $S$: Initial stock
price. 
- $K$: Strike price. 
- $R_u$ and $R_d$: Upward and downward
factors for stock price changes.

### R Code:

```{r explicit_binomial_with_delta_1, CACHE = TRUE}
#(a): Generate Price Matrix and Delta Matrix
 explicit_binomial_with_delta_1 <- function(T, S, K, Ru, Rd) {
  # Initialize price matrix and delta matrix
  price_matrix <- matrix(0, nrow = T + 1, ncol = T + 1)
  delta_matrix <- matrix(0, nrow = T, ncol = T)
  
  # Calculate stock prices and option payoffs at maturity
  for (i in 0:T) {
    price_matrix_a[i + 1, T + 1] <- S * Ru^i * Rd^(T - i)
  }
  
  # Calculate the call option payoff at maturity
  price_matrix_a[, T + 1] <- pmax(price_matrix[, T + 1] - K, 0)
  
  # Backward induction to calculate option prices and delta
  for (t in (T - 1):0) {
    for (i in 0:t) {
  # Option price at current time and state
  price_matrix_a[i + 1, t + 1] <- 0.5 * (price_matrix_a[i + 1, t + 2] + 
                                           price_matrix_a[i + 2, t + 2])
      
  # Calculate delta (the option's sensitivity to the stock price)
  delta_matrix[i + 1, t + 1] <-
    (price_matrix_a[i + 2, t + 2] - price_matrix_a[i + 1, t + 2]) / 
    (S * (Ru - Rd))
    }
  }
  
  return(list(price_matrix = price_matrix_a, delta_matrix = delta_matrix_a))
}
```

Stock prices and payoff at maturity: At maturity (t = T), the stock
price for each state is calculated as:

$$
S_{\text{state}} = S \cdot R_u^i \cdot R_d^{T-i}
$$

The call option payoff at maturity is given by:

$$
\text{Payoff} = \max(S\_{\text{state}} - K, 0)
$$

```{r price_matrix, CACHE = TRUE}

T <- 100
S <- 100
K <- 100
Ru <- 1.02
Rd <- 0.99

# Initialize the price_matrix
price_matrix <- matrix(0, nrow = T + 1, ncol = T + 1)

# Loop to fill the price matrix
for (i in 0:T) {
  price_matrix[i + 1, T + 1] <- S * Ru^i * Rd^(T - i)
}

# Update the last column to reflect option payoff
price_matrix[, T + 1] <- pmax(price_matrix[, T + 1] - K, 0)



for (i in 0:T) {
  price_matrix[i + 1, T + 1] <- S * Ru^i * Rd^(T - i)
}
price_matrix[, T + 1] <- pmax(price_matrix[, T + 1] - K, 0)
```

Backward induction:

Option prices are calculated recursively from maturity to the initial
time (t = 0) using:

$$
\text{Option Price} = 0.5 \cdot (\text{Option Price at Upward State} + \text{Option Price at Downward State})
$$

The Delta is calculated as:

$$
\Delta = \frac{\text{Option Price at Upward State} - \text{Option Price at Downward State}}{S \cdot (R_u - R_d)}
$$

```{r explicit_binomial_with_delta, CACHE = TRUE}
explicit_binomial_with_delta <- function(T, S, K, Ru, Rd) {
  # Initialize price matrix and delta matrix
  price_matrix_a <- matrix(0, nrow = T + 1, ncol = T + 1)
  delta_matrix <- matrix(0, nrow = T, ncol = T)
  
  # Calculate stock prices and option payoffs at maturity
  for (i in 0:T) {
    price_matrix_a[i + 1, T + 1] <- S * Ru^i * Rd^(T - i)
  }
  
  # Calculate the call option payoff at maturity
  price_matrix_a[, T + 1] <- pmax(price_matrix_a[, T + 1] - K, 0)
  
  # Backward induction to calculate option prices and delta
  for (t in (T - 1):0) {
    for (i in 0:t) {
      # Option price at current time and state
      price_matrix_a[i + 1, t + 1] <- 
        0.5 * (price_matrix_a[i + 1, t + 2] + price_matrix_a[i + 2, t + 2])
      
      # Calculate delta (the option's sensitivity to the stock price)
      delta_matrix[i + 1, t + 1] <- 
        (price_matrix_a[i + 2, t + 2] - price_matrix_a[i + 1, t + 2]) / 
        (S * (Ru - Rd))
    }
  }
  
  # Return both price matrix and delta matrix
  return(list(price_matrix = price_matrix_a, delta_matrix = delta_matrix))
}

T <- 100
S <- 100
K <- 100
Ru <- 1.02
Rd <- 0.99

# Call the function and store the result
result <- explicit_binomial_with_delta(T, S, K, Ru, Rd)

# Extract price matrix and delta matrix
price_matrix <- result$price_matrix
delta_matrix <- result$delta_matrix

```

#b) Generating sample path of binomial and hedging portfolio

We simulate a sample path for the binomial model and compute the
hedging portfolio at each time step. The portfolio is rebalanced to
match the option's delta at every step.

Logic:

1.  The stock price follows a binomial process with upward $R_u$ and
    downward $R_d$ movements.

2.  The portfolio at time t is: $$
    V_t = \Delta\_t \cdot S_t - (C_t - \Delta\_t \cdot S_t)
    $$

3.  The portfolio is adjusted at each step to match the delta of the
    option

```{r hedging_portfolio, CACHE = TRUE}
binomial_hedging_simulation <- function(T, S, K, Ru, Rd, r, p) {
  # Initialize arrays for stock prices, option prices, portfolio values,
  #and deltas
  stock_prices <- numeric(T + 1)
  option_prices <- numeric(T + 1)
  portfolio_values <- numeric(T + 1)
  deltas <- numeric(T + 1)
  
  # Set initial stock price
  stock_prices[1] <- S
  
  # Compute option value at the last time step (option payoff at expiration)
  #European Call Option Payoff
  option_prices[T + 1] <- max(stock_prices[1] * Ru^T - K, 0)
  
  
  #Compute option prices backward through the binomial tree
  #(using the risk-neutral probabilities)
  for (t in T:1) {
    for (i in 1:t) {
      option_prices[i] <- exp(-r) * (p * option_prices[i] + (1 - p) * 
                                       option_prices[i + 1])
    }
  }
  
  # Simulate stock prices and calculate portfolio values
  for (t in 1:T) {
    # Simulate stock price movement
    stock_prices[t + 1] <- if (runif(1) < 0.5) stock_prices[t] * 
      Ru else stock_prices[t] * Rd
    
    # Delta calculation
    deltas[t] <- (option_prices[t + 1] - option_prices[t]) / 
                 (stock_prices[t + 1] - stock_prices[t])

    # Portfolio value calculation
    cash_balance <- option_prices[t] - deltas[t] * stock_prices[t]
    portfolio_values[t + 1] <- deltas[t] * stock_prices[t + 1] + cash_balance
  }

  return(list(
    stock_prices = stock_prices,
    option_prices = option_prices,
    portfolio_values = portfolio_values,
    deltas = deltas
  ))
}

# Set Parameters for the simulation
T <- 10  # Number of time steps
S <- 100  # Initial stock price
K <- 100  # Strike price
Ru <- 1.1  # Up factor
Rd <- 0.9  # Down factor
r <- 0.05  # Risk-free rate (5%)
p <- 0.5   # Probability of an up movement

# Run the binomial hedging simulation
hedging_result <- binomial_hedging_simulation(T, S, K, Ru, Rd, r, p)

# Set minimum and maximum values for the plot
min_value <- min(c(hedging_result$stock_prices, hedging_result$option_prices, 
                   hedging_result$portfolio_values))
max_value <- max(c(hedging_result$stock_prices, hedging_result$option_prices, 
                   hedging_result$portfolio_values))

# Plotting
matplot(
  1:(T + 1), 
  cbind(hedging_result$stock_prices, hedging_result$option_prices, 
        hedging_result$portfolio_values), 
  type = "l", lty = c(2, 1, 3), col = c("blue", "orange", "black"),
  xlab = "Time", ylab = "Value", 
  main = "Hedging Portfolio Simulation"
)
```

#c) Adjust Hedging Portfolio Every Other Period

Here, we adjust the hedging portfolio only every other period. The
portfolio value is maintained, but the equity holdings are updated to
match the option delta.

1.  Adjust the hedging portfolio every p, where p = 2.
2.  Portfolio value remains constant between rebalancing.
3.  Stock prices follow the binomial process as before.

```{r stock_prices, CACHE = TRUE}
adjusted_hedging_portfolio <- 
  function(T, S, K, Ru, Rd, delta_matrix, 
           rebalancing_period = 2) {
  stock_prices <- numeric(T + 1)
  option_prices <- numeric(T + 1)
  portfolio_values <- numeric(T + 1)
  deltas <- numeric(T + 1)
  
  stock_prices[1] <- S
  option_prices[1] <- price_matrix[1, 1]
  deltas[1] <- delta_matrix[1, 1]
  portfolio_values[1] <- deltas[1] * S
  
  for (t in 1:T) {
    if (runif(1) < 0.5) {
      stock_prices[t + 1] <- stock_prices[t] * Ru
    } else {
      stock_prices[t + 1] <- stock_prices[t] * Rd
    }
    if (t %% rebalancing_period == 0) {
      deltas[t + 1] <- delta_matrix[t + 1, t + 1]
      portfolio_values[t + 1] <- deltas[t + 1] * stock_prices[t + 1]
    } else {
      portfolio_values[t + 1] <- portfolio_values[t]
    }
  }
  
  return(list(stock_prices = stock_prices, option_prices = option_prices, 
              portfolio_values = portfolio_values, deltas = deltas))
}

# Ensure the delta_matrix is properly initialized with the correct size
delta_matrix <- matrix(0, nrow = T + 1, ncol = T + 1)

# Perform the backward iteration for pricing and delta calculation
for (t in (T - 1):0) {
  for (i in 0:t) {
    # Ensure the indices are within the bounds
    if (t + 1 <= T + 1 && i + 1 <= T + 1) {
      price_matrix[i + 1, t + 1] <- 
        0.5 * (price_matrix[i + 1, t + 2] + price_matrix[i + 2, t + 2])
      
      # Calculate delta safely with proper indexing
      if (i + 2 <= T + 1) {
        delta_matrix[i + 1, t + 1] <- 
          (price_matrix[i + 2, t + 2] - price_matrix[i + 1, t + 2]) / 
          (S * (Ru - Rd))
      }
    }
  }
}

# Now you can call the adjusted_hedging_portfolio function safely
adjusted_result <- adjusted_hedging_portfolio(T, S, K, Ru, Rd, delta_matrix)


# Ensure that adjusted_result has valid data
if (length(adjusted_result$stock_prices) > 
    0 && length(adjusted_result$option_prices) > 
    0 && length(adjusted_result$portfolio_values) > 0) {
  
# Initialize the plot with stock prices
  plot(1:(T + 1), adjusted_result$stock_prices, type = "l", col = "blue", 
       lwd = 2, 
       xlab = "Time", ylab = "Value", ylim = c(min_value, max_value), 
       main = "Adjusted Hedging Portfolio")
  
# Add lines for option prices and portfolio values
  lines(1:(T + 1), adjusted_result$option_prices, col = "red", lwd = 2)
  lines(1:(T + 1), adjusted_result$portfolio_values, col = "green", lwd = 2)

# Add a legend to the top right corner
  legend("topright", legend = c("Stock Price", "Option Price", 
                                "Portfolio Value"), 
         col = c("blue", "red", "green"), lty = 1, lwd = 2)
  
} else {
# Error message if the data is not valid
  print("Error: Invalid or empty data in adjusted_result. 
        Please check the data structure.")
}


```

#d) Monte Carlo Method for Tracking Error

We calculate the tracking error using Monte Carlo simulations. The
tracking error is the standard deviation of the difference between the
portfolio value and the option value at each time.

Logic:

1.Run "N" Monte Carlo simulations.

2.Compute the difference between the portfolio and option values at
each time step.

3.Calculate the standard deviation of these differences as the
tracking error.

```{r tracking_error_montecarlo, CACHE = TRUE}
tracking_error_montecarlo <- function(T, S, K, Ru, Rd, N) {
  # Initialize a vector to store tracking errors
  tracking_errors <- numeric(T + 1)
  
  for (i in 1:N) {
    # Run the binomial hedging simulation to get portfolio and option values
    hedging_result <- binomial_hedging_simulation(T, S, K, Ru, Rd, 
                                                  r = 0.05, p = 0.5)
    
    # Calculate the difference between the portfolio
    #and option prices at each time step
    error <- hedging_result$portfolio_values - hedging_result$option_prices
    
    # Sum the squared errors to accumulate the tracking error
    tracking_errors <- tracking_errors + error^2
  }
  
  # Return the standard deviation (tracking error)
  return(sqrt(tracking_errors / N))
}

# Parameters for Monte Carlo simulation
N <- 10000  # Number of simulations
T <- 10     # Time steps
S <- 100    # Initial stock price
K <- 100    # Strike price
Ru <- 1.1   # Up factor
Rd <- 0.9   # Down factor

# Run the tracking error simulation
tracking_error_result <- tracking_error_montecarlo(T, S, K, Ru, Rd, N)

# Plotting the tracking error over time
plot(1:(T + 1), tracking_error_result, type = "l", col = "purple", 
     xlab = "Time", ylab = "Tracking Error", main = "Tracking Error Over Time")

```
